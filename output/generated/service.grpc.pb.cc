// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: service.proto

#include "service.pb.h"
#include "service.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace service {

static const char* AudioAdapter_method_names[] = {
  "/service.AudioAdapter/requestPlayAudioAdapter",
  "/service.AudioAdapter/requestStopAudioAdapter",
};

std::unique_ptr< AudioAdapter::Stub> AudioAdapter::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< AudioAdapter::Stub> stub(new AudioAdapter::Stub(channel));
  return stub;
}

AudioAdapter::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_requestPlayAudioAdapter_(AudioAdapter_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_requestStopAudioAdapter_(AudioAdapter_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status AudioAdapter::Stub::requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_requestPlayAudioAdapter_, context, request, response);
}

void AudioAdapter::Stub::experimental_async::requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestPlayAudioAdapter_, context, request, response, std::move(f));
}

void AudioAdapter::Stub::experimental_async::requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestPlayAudioAdapter_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioAdapter::Stub::PrepareAsyncrequestPlayAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::AudioDataResponse, ::service::AudioDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_requestPlayAudioAdapter_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioAdapter::Stub::AsyncrequestPlayAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncrequestPlayAudioAdapterRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status AudioAdapter::Stub::requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_requestStopAudioAdapter_, context, request, response);
}

void AudioAdapter::Stub::experimental_async::requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestStopAudioAdapter_, context, request, response, std::move(f));
}

void AudioAdapter::Stub::experimental_async::requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestStopAudioAdapter_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioAdapter::Stub::PrepareAsyncrequestStopAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::AudioDataResponse, ::service::AudioDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_requestStopAudioAdapter_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioAdapter::Stub::AsyncrequestStopAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncrequestStopAudioAdapterRaw(context, request, cq);
  result->StartCall();
  return result;
}

AudioAdapter::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AudioAdapter_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AudioAdapter::Service, ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](AudioAdapter::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::AudioDataRequest* req,
             ::service::AudioDataResponse* resp) {
               return service->requestPlayAudioAdapter(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AudioAdapter_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AudioAdapter::Service, ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](AudioAdapter::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::AudioDataRequest* req,
             ::service::AudioDataResponse* resp) {
               return service->requestStopAudioAdapter(ctx, req, resp);
             }, this)));
}

AudioAdapter::Service::~Service() {
}

::grpc::Status AudioAdapter::Service::requestPlayAudioAdapter(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AudioAdapter::Service::requestStopAudioAdapter(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* HMIAdapter_method_names[] = {
  "/service.HMIAdapter/requestButtonHMIAdapter",
};

std::unique_ptr< HMIAdapter::Stub> HMIAdapter::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< HMIAdapter::Stub> stub(new HMIAdapter::Stub(channel));
  return stub;
}

HMIAdapter::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_requestButtonHMIAdapter_(HMIAdapter_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status HMIAdapter::Stub::requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::service::HMIDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::HMIDataRequest, ::service::HMIDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_requestButtonHMIAdapter_, context, request, response);
}

void HMIAdapter::Stub::experimental_async::requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::HMIDataRequest, ::service::HMIDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestButtonHMIAdapter_, context, request, response, std::move(f));
}

void HMIAdapter::Stub::experimental_async::requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestButtonHMIAdapter_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* HMIAdapter::Stub::PrepareAsyncrequestButtonHMIAdapterRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::HMIDataResponse, ::service::HMIDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_requestButtonHMIAdapter_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* HMIAdapter::Stub::AsyncrequestButtonHMIAdapterRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncrequestButtonHMIAdapterRaw(context, request, cq);
  result->StartCall();
  return result;
}

HMIAdapter::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      HMIAdapter_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< HMIAdapter::Service, ::service::HMIDataRequest, ::service::HMIDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](HMIAdapter::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::HMIDataRequest* req,
             ::service::HMIDataResponse* resp) {
               return service->requestButtonHMIAdapter(ctx, req, resp);
             }, this)));
}

HMIAdapter::Service::~Service() {
}

::grpc::Status HMIAdapter::Service::requestButtonHMIAdapter(::grpc::ServerContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* MQTTAdapter_method_names[] = {
  "/service.MQTTAdapter/sendTriggerDataCANToMQTTSrv",
};

std::unique_ptr< MQTTAdapter::Stub> MQTTAdapter::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MQTTAdapter::Stub> stub(new MQTTAdapter::Stub(channel));
  return stub;
}

MQTTAdapter::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_sendTriggerDataCANToMQTTSrv_(MQTTAdapter_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MQTTAdapter::Stub::sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::service::MQTTDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::MQTTDataRequest, ::service::MQTTDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_sendTriggerDataCANToMQTTSrv_, context, request, response);
}

void MQTTAdapter::Stub::experimental_async::sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::MQTTDataRequest, ::service::MQTTDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_sendTriggerDataCANToMQTTSrv_, context, request, response, std::move(f));
}

void MQTTAdapter::Stub::experimental_async::sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_sendTriggerDataCANToMQTTSrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* MQTTAdapter::Stub::PrepareAsyncsendTriggerDataCANToMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::MQTTDataResponse, ::service::MQTTDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_sendTriggerDataCANToMQTTSrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* MQTTAdapter::Stub::AsyncsendTriggerDataCANToMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncsendTriggerDataCANToMQTTSrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

MQTTAdapter::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MQTTAdapter_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MQTTAdapter::Service, ::service::MQTTDataRequest, ::service::MQTTDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MQTTAdapter::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::MQTTDataRequest* req,
             ::service::MQTTDataResponse* resp) {
               return service->sendTriggerDataCANToMQTTSrv(ctx, req, resp);
             }, this)));
}

MQTTAdapter::Service::~Service() {
}

::grpc::Status MQTTAdapter::Service::sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* ServiceManager_method_names[] = {
  "/service.ServiceManager/registerHMIMgrService",
  "/service.ServiceManager/registerAudioMgrService",
  "/service.ServiceManager/registerMQTTMgrService",
};

std::unique_ptr< ServiceManager::Stub> ServiceManager::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ServiceManager::Stub> stub(new ServiceManager::Stub(channel));
  return stub;
}

ServiceManager::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_registerHMIMgrService_(ServiceManager_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_registerAudioMgrService_(ServiceManager_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_registerMQTTMgrService_(ServiceManager_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status ServiceManager::Stub::registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::service::RegisterHMIResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::RegisterHMIRequest, ::service::RegisterHMIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_registerHMIMgrService_, context, request, response);
}

void ServiceManager::Stub::experimental_async::registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::RegisterHMIRequest, ::service::RegisterHMIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerHMIMgrService_, context, request, response, std::move(f));
}

void ServiceManager::Stub::experimental_async::registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerHMIMgrService_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>* ServiceManager::Stub::PrepareAsyncregisterHMIMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::RegisterHMIResponse, ::service::RegisterHMIRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_registerHMIMgrService_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>* ServiceManager::Stub::AsyncregisterHMIMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregisterHMIMgrServiceRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ServiceManager::Stub::registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::service::RegisterAudioResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::RegisterAudioRequest, ::service::RegisterAudioResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_registerAudioMgrService_, context, request, response);
}

void ServiceManager::Stub::experimental_async::registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::RegisterAudioRequest, ::service::RegisterAudioResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerAudioMgrService_, context, request, response, std::move(f));
}

void ServiceManager::Stub::experimental_async::registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerAudioMgrService_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>* ServiceManager::Stub::PrepareAsyncregisterAudioMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::RegisterAudioResponse, ::service::RegisterAudioRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_registerAudioMgrService_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>* ServiceManager::Stub::AsyncregisterAudioMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregisterAudioMgrServiceRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ServiceManager::Stub::registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::service::RegisterMQTTResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_registerMQTTMgrService_, context, request, response);
}

void ServiceManager::Stub::experimental_async::registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerMQTTMgrService_, context, request, response, std::move(f));
}

void ServiceManager::Stub::experimental_async::registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerMQTTMgrService_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>* ServiceManager::Stub::PrepareAsyncregisterMQTTMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::RegisterMQTTResponse, ::service::RegisterMQTTRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_registerMQTTMgrService_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>* ServiceManager::Stub::AsyncregisterMQTTMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregisterMQTTMgrServiceRaw(context, request, cq);
  result->StartCall();
  return result;
}

ServiceManager::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ServiceManager_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ServiceManager::Service, ::service::RegisterHMIRequest, ::service::RegisterHMIResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ServiceManager::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::RegisterHMIRequest* req,
             ::service::RegisterHMIResponse* resp) {
               return service->registerHMIMgrService(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ServiceManager_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ServiceManager::Service, ::service::RegisterAudioRequest, ::service::RegisterAudioResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ServiceManager::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::RegisterAudioRequest* req,
             ::service::RegisterAudioResponse* resp) {
               return service->registerAudioMgrService(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ServiceManager_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ServiceManager::Service, ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ServiceManager::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::RegisterMQTTRequest* req,
             ::service::RegisterMQTTResponse* resp) {
               return service->registerMQTTMgrService(ctx, req, resp);
             }, this)));
}

ServiceManager::Service::~Service() {
}

::grpc::Status ServiceManager::Service::registerHMIMgrService(::grpc::ServerContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ServiceManager::Service::registerAudioMgrService(::grpc::ServerContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ServiceManager::Service::registerMQTTMgrService(::grpc::ServerContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* HMISrv_method_names[] = {
  "/service.HMISrv/registerHMISrv",
  "/service.HMISrv/requestButtonHMISrv",
};

std::unique_ptr< HMISrv::Stub> HMISrv::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< HMISrv::Stub> stub(new HMISrv::Stub(channel));
  return stub;
}

HMISrv::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_registerHMISrv_(HMISrv_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_requestButtonHMISrv_(HMISrv_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status HMISrv::Stub::registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::service::HMIServiceResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::HMIServiceRequest, ::service::HMIServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_registerHMISrv_, context, request, response);
}

void HMISrv::Stub::experimental_async::registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::HMIServiceRequest, ::service::HMIServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerHMISrv_, context, request, response, std::move(f));
}

void HMISrv::Stub::experimental_async::registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerHMISrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>* HMISrv::Stub::PrepareAsyncregisterHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::HMIServiceResponse, ::service::HMIServiceRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_registerHMISrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>* HMISrv::Stub::AsyncregisterHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregisterHMISrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status HMISrv::Stub::requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::service::HMIDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::HMIDataRequest, ::service::HMIDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_requestButtonHMISrv_, context, request, response);
}

void HMISrv::Stub::experimental_async::requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::HMIDataRequest, ::service::HMIDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestButtonHMISrv_, context, request, response, std::move(f));
}

void HMISrv::Stub::experimental_async::requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_requestButtonHMISrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* HMISrv::Stub::PrepareAsyncrequestButtonHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::HMIDataResponse, ::service::HMIDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_requestButtonHMISrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* HMISrv::Stub::AsyncrequestButtonHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncrequestButtonHMISrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

HMISrv::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      HMISrv_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< HMISrv::Service, ::service::HMIServiceRequest, ::service::HMIServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](HMISrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::HMIServiceRequest* req,
             ::service::HMIServiceResponse* resp) {
               return service->registerHMISrv(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      HMISrv_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< HMISrv::Service, ::service::HMIDataRequest, ::service::HMIDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](HMISrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::HMIDataRequest* req,
             ::service::HMIDataResponse* resp) {
               return service->requestButtonHMISrv(ctx, req, resp);
             }, this)));
}

HMISrv::Service::~Service() {
}

::grpc::Status HMISrv::Service::registerHMISrv(::grpc::ServerContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status HMISrv::Service::requestButtonHMISrv(::grpc::ServerContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* AudioSrv_method_names[] = {
  "/service.AudioSrv/registerAudioSrv",
  "/service.AudioSrv/receivePlayAudioSrv",
  "/service.AudioSrv/receiveStopAudioSrv",
};

std::unique_ptr< AudioSrv::Stub> AudioSrv::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< AudioSrv::Stub> stub(new AudioSrv::Stub(channel));
  return stub;
}

AudioSrv::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_registerAudioSrv_(AudioSrv_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_receivePlayAudioSrv_(AudioSrv_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_receiveStopAudioSrv_(AudioSrv_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status AudioSrv::Stub::registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::service::AudioServiceResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::AudioServiceRequest, ::service::AudioServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_registerAudioSrv_, context, request, response);
}

void AudioSrv::Stub::experimental_async::registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::AudioServiceRequest, ::service::AudioServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerAudioSrv_, context, request, response, std::move(f));
}

void AudioSrv::Stub::experimental_async::registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerAudioSrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>* AudioSrv::Stub::PrepareAsyncregisterAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::AudioServiceResponse, ::service::AudioServiceRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_registerAudioSrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>* AudioSrv::Stub::AsyncregisterAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregisterAudioSrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status AudioSrv::Stub::receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_receivePlayAudioSrv_, context, request, response);
}

void AudioSrv::Stub::experimental_async::receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_receivePlayAudioSrv_, context, request, response, std::move(f));
}

void AudioSrv::Stub::experimental_async::receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_receivePlayAudioSrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioSrv::Stub::PrepareAsyncreceivePlayAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::AudioDataResponse, ::service::AudioDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_receivePlayAudioSrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioSrv::Stub::AsyncreceivePlayAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncreceivePlayAudioSrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status AudioSrv::Stub::receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_receiveStopAudioSrv_, context, request, response);
}

void AudioSrv::Stub::experimental_async::receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_receiveStopAudioSrv_, context, request, response, std::move(f));
}

void AudioSrv::Stub::experimental_async::receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_receiveStopAudioSrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioSrv::Stub::PrepareAsyncreceiveStopAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::AudioDataResponse, ::service::AudioDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_receiveStopAudioSrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AudioSrv::Stub::AsyncreceiveStopAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncreceiveStopAudioSrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

AudioSrv::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AudioSrv_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AudioSrv::Service, ::service::AudioServiceRequest, ::service::AudioServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](AudioSrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::AudioServiceRequest* req,
             ::service::AudioServiceResponse* resp) {
               return service->registerAudioSrv(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AudioSrv_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AudioSrv::Service, ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](AudioSrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::AudioDataRequest* req,
             ::service::AudioDataResponse* resp) {
               return service->receivePlayAudioSrv(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AudioSrv_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AudioSrv::Service, ::service::AudioDataRequest, ::service::AudioDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](AudioSrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::AudioDataRequest* req,
             ::service::AudioDataResponse* resp) {
               return service->receiveStopAudioSrv(ctx, req, resp);
             }, this)));
}

AudioSrv::Service::~Service() {
}

::grpc::Status AudioSrv::Service::registerAudioSrv(::grpc::ServerContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AudioSrv::Service::receivePlayAudioSrv(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AudioSrv::Service::receiveStopAudioSrv(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* MQTTSrv_method_names[] = {
  "/service.MQTTSrv/registerMQTTSrv",
  "/service.MQTTSrv/receiveTriggerDataCAN",
};

std::unique_ptr< MQTTSrv::Stub> MQTTSrv::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MQTTSrv::Stub> stub(new MQTTSrv::Stub(channel));
  return stub;
}

MQTTSrv::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_registerMQTTSrv_(MQTTSrv_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_receiveTriggerDataCAN_(MQTTSrv_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MQTTSrv::Stub::registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::service::MQTTServiceResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::MQTTServiceRequest, ::service::MQTTServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_registerMQTTSrv_, context, request, response);
}

void MQTTSrv::Stub::experimental_async::registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::MQTTServiceRequest, ::service::MQTTServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerMQTTSrv_, context, request, response, std::move(f));
}

void MQTTSrv::Stub::experimental_async::registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_registerMQTTSrv_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>* MQTTSrv::Stub::PrepareAsyncregisterMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::MQTTServiceResponse, ::service::MQTTServiceRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_registerMQTTSrv_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>* MQTTSrv::Stub::AsyncregisterMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregisterMQTTSrvRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MQTTSrv::Stub::receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::service::MQTTDataResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::service::MQTTDataRequest, ::service::MQTTDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_receiveTriggerDataCAN_, context, request, response);
}

void MQTTSrv::Stub::experimental_async::receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::service::MQTTDataRequest, ::service::MQTTDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_receiveTriggerDataCAN_, context, request, response, std::move(f));
}

void MQTTSrv::Stub::experimental_async::receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_receiveTriggerDataCAN_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* MQTTSrv::Stub::PrepareAsyncreceiveTriggerDataCANRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::service::MQTTDataResponse, ::service::MQTTDataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_receiveTriggerDataCAN_, context, request);
}

::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* MQTTSrv::Stub::AsyncreceiveTriggerDataCANRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncreceiveTriggerDataCANRaw(context, request, cq);
  result->StartCall();
  return result;
}

MQTTSrv::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MQTTSrv_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MQTTSrv::Service, ::service::MQTTServiceRequest, ::service::MQTTServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MQTTSrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::MQTTServiceRequest* req,
             ::service::MQTTServiceResponse* resp) {
               return service->registerMQTTSrv(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MQTTSrv_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MQTTSrv::Service, ::service::MQTTDataRequest, ::service::MQTTDataResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MQTTSrv::Service* service,
             ::grpc::ServerContext* ctx,
             const ::service::MQTTDataRequest* req,
             ::service::MQTTDataResponse* resp) {
               return service->receiveTriggerDataCAN(ctx, req, resp);
             }, this)));
}

MQTTSrv::Service::~Service() {
}

::grpc::Status MQTTSrv::Service::registerMQTTSrv(::grpc::ServerContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MQTTSrv::Service::receiveTriggerDataCAN(::grpc::ServerContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace service

