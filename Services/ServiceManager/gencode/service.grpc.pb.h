// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: service.proto
#ifndef GRPC_service_2eproto__INCLUDED
#define GRPC_service_2eproto__INCLUDED

#include "service.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace service {

class AudioAdapter final {
 public:
  static constexpr char const* service_full_name() {
    return "service.AudioAdapter";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // AudioAdapter send request data to AudioSrv
    virtual ::grpc::Status requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> AsyncrequestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(AsyncrequestPlayAudioAdapterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> PrepareAsyncrequestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(PrepareAsyncrequestPlayAudioAdapterRaw(context, request, cq));
    }
    virtual ::grpc::Status requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> AsyncrequestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(AsyncrequestStopAudioAdapterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> PrepareAsyncrequestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(PrepareAsyncrequestStopAudioAdapterRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // AudioAdapter send request data to AudioSrv
      virtual void requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* AsyncrequestPlayAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* PrepareAsyncrequestPlayAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* AsyncrequestStopAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* PrepareAsyncrequestStopAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> AsyncrequestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(AsyncrequestPlayAudioAdapterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> PrepareAsyncrequestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(PrepareAsyncrequestPlayAudioAdapterRaw(context, request, cq));
    }
    ::grpc::Status requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> AsyncrequestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(AsyncrequestStopAudioAdapterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> PrepareAsyncrequestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(PrepareAsyncrequestStopAudioAdapterRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void requestPlayAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void requestStopAudioAdapter(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AsyncrequestPlayAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* PrepareAsyncrequestPlayAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AsyncrequestStopAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* PrepareAsyncrequestStopAudioAdapterRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_requestPlayAudioAdapter_;
    const ::grpc::internal::RpcMethod rpcmethod_requestStopAudioAdapter_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // AudioAdapter send request data to AudioSrv
    virtual ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response);
    virtual ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_requestPlayAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_requestPlayAudioAdapter() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_requestPlayAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestPlayAudioAdapter(::grpc::ServerContext* context, ::service::AudioDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::AudioDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_requestStopAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_requestStopAudioAdapter() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_requestStopAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestStopAudioAdapter(::grpc::ServerContext* context, ::service::AudioDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::AudioDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_requestPlayAudioAdapter<WithAsyncMethod_requestStopAudioAdapter<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_requestPlayAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_requestPlayAudioAdapter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) { return this->requestPlayAudioAdapter(context, request, response); }));}
    void SetMessageAllocatorFor_requestPlayAudioAdapter(
        ::grpc::experimental::MessageAllocator< ::service::AudioDataRequest, ::service::AudioDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_requestPlayAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestPlayAudioAdapter(
      ::grpc::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestPlayAudioAdapter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_requestStopAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_requestStopAudioAdapter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) { return this->requestStopAudioAdapter(context, request, response); }));}
    void SetMessageAllocatorFor_requestStopAudioAdapter(
        ::grpc::experimental::MessageAllocator< ::service::AudioDataRequest, ::service::AudioDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_requestStopAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestStopAudioAdapter(
      ::grpc::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestStopAudioAdapter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_requestPlayAudioAdapter<ExperimentalWithCallbackMethod_requestStopAudioAdapter<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_requestPlayAudioAdapter<ExperimentalWithCallbackMethod_requestStopAudioAdapter<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_requestPlayAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_requestPlayAudioAdapter() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_requestPlayAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_requestStopAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_requestStopAudioAdapter() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_requestStopAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_requestPlayAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_requestPlayAudioAdapter() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_requestPlayAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestPlayAudioAdapter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_requestStopAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_requestStopAudioAdapter() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_requestStopAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestStopAudioAdapter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_requestPlayAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_requestPlayAudioAdapter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->requestPlayAudioAdapter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_requestPlayAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestPlayAudioAdapter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestPlayAudioAdapter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_requestStopAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_requestStopAudioAdapter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->requestStopAudioAdapter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_requestStopAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestStopAudioAdapter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestStopAudioAdapter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_requestPlayAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_requestPlayAudioAdapter() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::AudioDataRequest, ::service::AudioDataResponse>* streamer) {
                       return this->StreamedrequestPlayAudioAdapter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_requestPlayAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status requestPlayAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrequestPlayAudioAdapter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::AudioDataRequest,::service::AudioDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_requestStopAudioAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_requestStopAudioAdapter() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::AudioDataRequest, ::service::AudioDataResponse>* streamer) {
                       return this->StreamedrequestStopAudioAdapter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_requestStopAudioAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status requestStopAudioAdapter(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrequestStopAudioAdapter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::AudioDataRequest,::service::AudioDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_requestPlayAudioAdapter<WithStreamedUnaryMethod_requestStopAudioAdapter<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_requestPlayAudioAdapter<WithStreamedUnaryMethod_requestStopAudioAdapter<Service > > StreamedService;
};

// HMIAdapter
//
class HMIAdapter final {
 public:
  static constexpr char const* service_full_name() {
    return "service.HMIAdapter";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // HMIADapter receive data from HMISrv
    virtual ::grpc::Status requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::service::HMIDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>> AsyncrequestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>>(AsyncrequestButtonHMIAdapterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>> PrepareAsyncrequestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>>(PrepareAsyncrequestButtonHMIAdapterRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // HMIADapter receive data from HMISrv
      virtual void requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>* AsyncrequestButtonHMIAdapterRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>* PrepareAsyncrequestButtonHMIAdapterRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::service::HMIDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>> AsyncrequestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>>(AsyncrequestButtonHMIAdapterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>> PrepareAsyncrequestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>>(PrepareAsyncrequestButtonHMIAdapterRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void requestButtonHMIAdapter(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* AsyncrequestButtonHMIAdapterRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* PrepareAsyncrequestButtonHMIAdapterRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_requestButtonHMIAdapter_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // HMIADapter receive data from HMISrv
    virtual ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_requestButtonHMIAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_requestButtonHMIAdapter() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_requestButtonHMIAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestButtonHMIAdapter(::grpc::ServerContext* context, ::service::HMIDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::HMIDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_requestButtonHMIAdapter<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_requestButtonHMIAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_requestButtonHMIAdapter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::HMIDataRequest, ::service::HMIDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response) { return this->requestButtonHMIAdapter(context, request, response); }));}
    void SetMessageAllocatorFor_requestButtonHMIAdapter(
        ::grpc::experimental::MessageAllocator< ::service::HMIDataRequest, ::service::HMIDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::HMIDataRequest, ::service::HMIDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_requestButtonHMIAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestButtonHMIAdapter(
      ::grpc::CallbackServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestButtonHMIAdapter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_requestButtonHMIAdapter<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_requestButtonHMIAdapter<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_requestButtonHMIAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_requestButtonHMIAdapter() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_requestButtonHMIAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_requestButtonHMIAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_requestButtonHMIAdapter() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_requestButtonHMIAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestButtonHMIAdapter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_requestButtonHMIAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_requestButtonHMIAdapter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->requestButtonHMIAdapter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_requestButtonHMIAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestButtonHMIAdapter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestButtonHMIAdapter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_requestButtonHMIAdapter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_requestButtonHMIAdapter() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::HMIDataRequest, ::service::HMIDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::HMIDataRequest, ::service::HMIDataResponse>* streamer) {
                       return this->StreamedrequestButtonHMIAdapter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_requestButtonHMIAdapter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status requestButtonHMIAdapter(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrequestButtonHMIAdapter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::HMIDataRequest,::service::HMIDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_requestButtonHMIAdapter<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_requestButtonHMIAdapter<Service > StreamedService;
};

// MQTTAdapter
//
class MQTTAdapter final {
 public:
  static constexpr char const* service_full_name() {
    return "service.MQTTAdapter";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // MQTTAdapter send data request CAN to MQTTSrv
    virtual ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::service::MQTTDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>> AsyncsendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>>(AsyncsendTriggerDataCANToMQTTSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>> PrepareAsyncsendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>>(PrepareAsyncsendTriggerDataCANToMQTTSrvRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // MQTTAdapter send data request CAN to MQTTSrv
      virtual void sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>* AsyncsendTriggerDataCANToMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>* PrepareAsyncsendTriggerDataCANToMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::service::MQTTDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>> AsyncsendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>>(AsyncsendTriggerDataCANToMQTTSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>> PrepareAsyncsendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>>(PrepareAsyncsendTriggerDataCANToMQTTSrvRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendTriggerDataCANToMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* AsyncsendTriggerDataCANToMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* PrepareAsyncsendTriggerDataCANToMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_sendTriggerDataCANToMQTTSrv_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // MQTTAdapter send data request CAN to MQTTSrv
    virtual ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_sendTriggerDataCANToMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendTriggerDataCANToMQTTSrv() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_sendTriggerDataCANToMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendTriggerDataCANToMQTTSrv(::grpc::ServerContext* context, ::service::MQTTDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::MQTTDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_sendTriggerDataCANToMQTTSrv<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendTriggerDataCANToMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendTriggerDataCANToMQTTSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::MQTTDataRequest, ::service::MQTTDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response) { return this->sendTriggerDataCANToMQTTSrv(context, request, response); }));}
    void SetMessageAllocatorFor_sendTriggerDataCANToMQTTSrv(
        ::grpc::experimental::MessageAllocator< ::service::MQTTDataRequest, ::service::MQTTDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::MQTTDataRequest, ::service::MQTTDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendTriggerDataCANToMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendTriggerDataCANToMQTTSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendTriggerDataCANToMQTTSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_sendTriggerDataCANToMQTTSrv<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_sendTriggerDataCANToMQTTSrv<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_sendTriggerDataCANToMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendTriggerDataCANToMQTTSrv() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_sendTriggerDataCANToMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendTriggerDataCANToMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendTriggerDataCANToMQTTSrv() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_sendTriggerDataCANToMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendTriggerDataCANToMQTTSrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendTriggerDataCANToMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendTriggerDataCANToMQTTSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendTriggerDataCANToMQTTSrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendTriggerDataCANToMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendTriggerDataCANToMQTTSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendTriggerDataCANToMQTTSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendTriggerDataCANToMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendTriggerDataCANToMQTTSrv() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::MQTTDataRequest, ::service::MQTTDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::MQTTDataRequest, ::service::MQTTDataResponse>* streamer) {
                       return this->StreamedsendTriggerDataCANToMQTTSrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendTriggerDataCANToMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendTriggerDataCANToMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendTriggerDataCANToMQTTSrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::MQTTDataRequest,::service::MQTTDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_sendTriggerDataCANToMQTTSrv<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_sendTriggerDataCANToMQTTSrv<Service > StreamedService;
};

// ServiceManager
class ServiceManager final {
 public:
  static constexpr char const* service_full_name() {
    return "service.ServiceManager";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::service::RegisterHMIResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterHMIResponse>> AsyncregisterHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterHMIResponse>>(AsyncregisterHMIMgrServiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterHMIResponse>> PrepareAsyncregisterHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterHMIResponse>>(PrepareAsyncregisterHMIMgrServiceRaw(context, request, cq));
    }
    virtual ::grpc::Status registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::service::RegisterAudioResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterAudioResponse>> AsyncregisterAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterAudioResponse>>(AsyncregisterAudioMgrServiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterAudioResponse>> PrepareAsyncregisterAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterAudioResponse>>(PrepareAsyncregisterAudioMgrServiceRaw(context, request, cq));
    }
    virtual ::grpc::Status registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::service::RegisterMQTTResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterMQTTResponse>> AsyncregisterMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterMQTTResponse>>(AsyncregisterMQTTMgrServiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterMQTTResponse>> PrepareAsyncregisterMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterMQTTResponse>>(PrepareAsyncregisterMQTTMgrServiceRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterHMIResponse>* AsyncregisterHMIMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterHMIResponse>* PrepareAsyncregisterHMIMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterAudioResponse>* AsyncregisterAudioMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterAudioResponse>* PrepareAsyncregisterAudioMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterMQTTResponse>* AsyncregisterMQTTMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::RegisterMQTTResponse>* PrepareAsyncregisterMQTTMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::service::RegisterHMIResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>> AsyncregisterHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>>(AsyncregisterHMIMgrServiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>> PrepareAsyncregisterHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>>(PrepareAsyncregisterHMIMgrServiceRaw(context, request, cq));
    }
    ::grpc::Status registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::service::RegisterAudioResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>> AsyncregisterAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>>(AsyncregisterAudioMgrServiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>> PrepareAsyncregisterAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>>(PrepareAsyncregisterAudioMgrServiceRaw(context, request, cq));
    }
    ::grpc::Status registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::service::RegisterMQTTResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>> AsyncregisterMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>>(AsyncregisterMQTTMgrServiceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>> PrepareAsyncregisterMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>>(PrepareAsyncregisterMQTTMgrServiceRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void registerHMIMgrService(::grpc::ClientContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void registerAudioMgrService(::grpc::ClientContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void registerMQTTMgrService(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>* AsyncregisterHMIMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::RegisterHMIResponse>* PrepareAsyncregisterHMIMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterHMIRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>* AsyncregisterAudioMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::RegisterAudioResponse>* PrepareAsyncregisterAudioMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterAudioRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>* AsyncregisterMQTTMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::RegisterMQTTResponse>* PrepareAsyncregisterMQTTMgrServiceRaw(::grpc::ClientContext* context, const ::service::RegisterMQTTRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_registerHMIMgrService_;
    const ::grpc::internal::RpcMethod rpcmethod_registerAudioMgrService_;
    const ::grpc::internal::RpcMethod rpcmethod_registerMQTTMgrService_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status registerHMIMgrService(::grpc::ServerContext* context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response);
    virtual ::grpc::Status registerAudioMgrService(::grpc::ServerContext* context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response);
    virtual ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_registerHMIMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerHMIMgrService() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_registerHMIMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMIMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterHMIMgrService(::grpc::ServerContext* context, ::service::RegisterHMIRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::RegisterHMIResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_registerAudioMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerAudioMgrService() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_registerAudioMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterAudioMgrService(::grpc::ServerContext* context, ::service::RegisterAudioRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::RegisterAudioResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_registerMQTTMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerMQTTMgrService() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_registerMQTTMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterMQTTMgrService(::grpc::ServerContext* context, ::service::RegisterMQTTRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::RegisterMQTTResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_registerHMIMgrService<WithAsyncMethod_registerAudioMgrService<WithAsyncMethod_registerMQTTMgrService<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_registerHMIMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_registerHMIMgrService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::RegisterHMIRequest, ::service::RegisterHMIResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::RegisterHMIRequest* request, ::service::RegisterHMIResponse* response) { return this->registerHMIMgrService(context, request, response); }));}
    void SetMessageAllocatorFor_registerHMIMgrService(
        ::grpc::experimental::MessageAllocator< ::service::RegisterHMIRequest, ::service::RegisterHMIResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::RegisterHMIRequest, ::service::RegisterHMIResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_registerHMIMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMIMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerHMIMgrService(
      ::grpc::CallbackServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerHMIMgrService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_registerAudioMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_registerAudioMgrService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::service::RegisterAudioRequest, ::service::RegisterAudioResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::RegisterAudioRequest* request, ::service::RegisterAudioResponse* response) { return this->registerAudioMgrService(context, request, response); }));}
    void SetMessageAllocatorFor_registerAudioMgrService(
        ::grpc::experimental::MessageAllocator< ::service::RegisterAudioRequest, ::service::RegisterAudioResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::RegisterAudioRequest, ::service::RegisterAudioResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_registerAudioMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerAudioMgrService(
      ::grpc::CallbackServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerAudioMgrService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_registerMQTTMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_registerMQTTMgrService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::RegisterMQTTRequest* request, ::service::RegisterMQTTResponse* response) { return this->registerMQTTMgrService(context, request, response); }));}
    void SetMessageAllocatorFor_registerMQTTMgrService(
        ::grpc::experimental::MessageAllocator< ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_registerMQTTMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerMQTTMgrService(
      ::grpc::CallbackServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerMQTTMgrService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_registerHMIMgrService<ExperimentalWithCallbackMethod_registerAudioMgrService<ExperimentalWithCallbackMethod_registerMQTTMgrService<Service > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_registerHMIMgrService<ExperimentalWithCallbackMethod_registerAudioMgrService<ExperimentalWithCallbackMethod_registerMQTTMgrService<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_registerHMIMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerHMIMgrService() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_registerHMIMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMIMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_registerAudioMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerAudioMgrService() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_registerAudioMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_registerMQTTMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerMQTTMgrService() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_registerMQTTMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerHMIMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerHMIMgrService() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_registerHMIMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMIMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterHMIMgrService(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerAudioMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerAudioMgrService() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_registerAudioMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterAudioMgrService(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerMQTTMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerMQTTMgrService() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_registerMQTTMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterMQTTMgrService(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_registerHMIMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_registerHMIMgrService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerHMIMgrService(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_registerHMIMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMIMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerHMIMgrService(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerHMIMgrService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_registerAudioMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_registerAudioMgrService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerAudioMgrService(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_registerAudioMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerAudioMgrService(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerAudioMgrService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_registerMQTTMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_registerMQTTMgrService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerMQTTMgrService(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_registerMQTTMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerMQTTMgrService(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerMQTTMgrService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerHMIMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerHMIMgrService() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::RegisterHMIRequest, ::service::RegisterHMIResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::RegisterHMIRequest, ::service::RegisterHMIResponse>* streamer) {
                       return this->StreamedregisterHMIMgrService(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerHMIMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerHMIMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterHMIRequest* /*request*/, ::service::RegisterHMIResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterHMIMgrService(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::RegisterHMIRequest,::service::RegisterHMIResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerAudioMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerAudioMgrService() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::RegisterAudioRequest, ::service::RegisterAudioResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::RegisterAudioRequest, ::service::RegisterAudioResponse>* streamer) {
                       return this->StreamedregisterAudioMgrService(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerAudioMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerAudioMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterAudioRequest* /*request*/, ::service::RegisterAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterAudioMgrService(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::RegisterAudioRequest,::service::RegisterAudioResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerMQTTMgrService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerMQTTMgrService() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::RegisterMQTTRequest, ::service::RegisterMQTTResponse>* streamer) {
                       return this->StreamedregisterMQTTMgrService(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerMQTTMgrService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerMQTTMgrService(::grpc::ServerContext* /*context*/, const ::service::RegisterMQTTRequest* /*request*/, ::service::RegisterMQTTResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterMQTTMgrService(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::RegisterMQTTRequest,::service::RegisterMQTTResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_registerHMIMgrService<WithStreamedUnaryMethod_registerAudioMgrService<WithStreamedUnaryMethod_registerMQTTMgrService<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_registerHMIMgrService<WithStreamedUnaryMethod_registerAudioMgrService<WithStreamedUnaryMethod_registerMQTTMgrService<Service > > > StreamedService;
};

// HMI Service
class HMISrv final {
 public:
  static constexpr char const* service_full_name() {
    return "service.HMISrv";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::service::HMIServiceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIServiceResponse>> AsyncregisterHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIServiceResponse>>(AsyncregisterHMISrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIServiceResponse>> PrepareAsyncregisterHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIServiceResponse>>(PrepareAsyncregisterHMISrvRaw(context, request, cq));
    }
    // HMISrv send data to HMIAdapter
    virtual ::grpc::Status requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::service::HMIDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>> AsyncrequestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>>(AsyncrequestButtonHMISrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>> PrepareAsyncrequestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>>(PrepareAsyncrequestButtonHMISrvRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // HMISrv send data to HMIAdapter
      virtual void requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIServiceResponse>* AsyncregisterHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIServiceResponse>* PrepareAsyncregisterHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>* AsyncrequestButtonHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::HMIDataResponse>* PrepareAsyncrequestButtonHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::service::HMIServiceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>> AsyncregisterHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>>(AsyncregisterHMISrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>> PrepareAsyncregisterHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>>(PrepareAsyncregisterHMISrvRaw(context, request, cq));
    }
    ::grpc::Status requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::service::HMIDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>> AsyncrequestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>>(AsyncrequestButtonHMISrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>> PrepareAsyncrequestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>>(PrepareAsyncrequestButtonHMISrvRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void registerHMISrv(::grpc::ClientContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void requestButtonHMISrv(::grpc::ClientContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>* AsyncregisterHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::HMIServiceResponse>* PrepareAsyncregisterHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIServiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* AsyncrequestButtonHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::HMIDataResponse>* PrepareAsyncrequestButtonHMISrvRaw(::grpc::ClientContext* context, const ::service::HMIDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_registerHMISrv_;
    const ::grpc::internal::RpcMethod rpcmethod_requestButtonHMISrv_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status registerHMISrv(::grpc::ServerContext* context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response);
    // HMISrv send data to HMIAdapter
    virtual ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_registerHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerHMISrv() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_registerHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterHMISrv(::grpc::ServerContext* context, ::service::HMIServiceRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::HMIServiceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_requestButtonHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_requestButtonHMISrv() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_requestButtonHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestButtonHMISrv(::grpc::ServerContext* context, ::service::HMIDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::HMIDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_registerHMISrv<WithAsyncMethod_requestButtonHMISrv<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_registerHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_registerHMISrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::HMIServiceRequest, ::service::HMIServiceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::HMIServiceRequest* request, ::service::HMIServiceResponse* response) { return this->registerHMISrv(context, request, response); }));}
    void SetMessageAllocatorFor_registerHMISrv(
        ::grpc::experimental::MessageAllocator< ::service::HMIServiceRequest, ::service::HMIServiceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::HMIServiceRequest, ::service::HMIServiceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_registerHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerHMISrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerHMISrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_requestButtonHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_requestButtonHMISrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::service::HMIDataRequest, ::service::HMIDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::HMIDataRequest* request, ::service::HMIDataResponse* response) { return this->requestButtonHMISrv(context, request, response); }));}
    void SetMessageAllocatorFor_requestButtonHMISrv(
        ::grpc::experimental::MessageAllocator< ::service::HMIDataRequest, ::service::HMIDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::HMIDataRequest, ::service::HMIDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_requestButtonHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestButtonHMISrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestButtonHMISrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_registerHMISrv<ExperimentalWithCallbackMethod_requestButtonHMISrv<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_registerHMISrv<ExperimentalWithCallbackMethod_requestButtonHMISrv<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_registerHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerHMISrv() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_registerHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_requestButtonHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_requestButtonHMISrv() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_requestButtonHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerHMISrv() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_registerHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterHMISrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_requestButtonHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_requestButtonHMISrv() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_requestButtonHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrequestButtonHMISrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_registerHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_registerHMISrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerHMISrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_registerHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerHMISrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerHMISrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_requestButtonHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_requestButtonHMISrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->requestButtonHMISrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_requestButtonHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* requestButtonHMISrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* requestButtonHMISrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerHMISrv() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::HMIServiceRequest, ::service::HMIServiceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::HMIServiceRequest, ::service::HMIServiceResponse>* streamer) {
                       return this->StreamedregisterHMISrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIServiceRequest* /*request*/, ::service::HMIServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterHMISrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::HMIServiceRequest,::service::HMIServiceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_requestButtonHMISrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_requestButtonHMISrv() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::HMIDataRequest, ::service::HMIDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::HMIDataRequest, ::service::HMIDataResponse>* streamer) {
                       return this->StreamedrequestButtonHMISrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_requestButtonHMISrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status requestButtonHMISrv(::grpc::ServerContext* /*context*/, const ::service::HMIDataRequest* /*request*/, ::service::HMIDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrequestButtonHMISrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::HMIDataRequest,::service::HMIDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_registerHMISrv<WithStreamedUnaryMethod_requestButtonHMISrv<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_registerHMISrv<WithStreamedUnaryMethod_requestButtonHMISrv<Service > > StreamedService;
};

// Audio Service
class AudioSrv final {
 public:
  static constexpr char const* service_full_name() {
    return "service.AudioSrv";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::service::AudioServiceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioServiceResponse>> AsyncregisterAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioServiceResponse>>(AsyncregisterAudioSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioServiceResponse>> PrepareAsyncregisterAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioServiceResponse>>(PrepareAsyncregisterAudioSrvRaw(context, request, cq));
    }
    // receive data AudioAdapter
    virtual ::grpc::Status receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> AsyncreceivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(AsyncreceivePlayAudioSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> PrepareAsyncreceivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(PrepareAsyncreceivePlayAudioSrvRaw(context, request, cq));
    }
    virtual ::grpc::Status receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> AsyncreceiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(AsyncreceiveStopAudioSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>> PrepareAsyncreceiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>>(PrepareAsyncreceiveStopAudioSrvRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // receive data AudioAdapter
      virtual void receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioServiceResponse>* AsyncregisterAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioServiceResponse>* PrepareAsyncregisterAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* AsyncreceivePlayAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* PrepareAsyncreceivePlayAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* AsyncreceiveStopAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::AudioDataResponse>* PrepareAsyncreceiveStopAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::service::AudioServiceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>> AsyncregisterAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>>(AsyncregisterAudioSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>> PrepareAsyncregisterAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>>(PrepareAsyncregisterAudioSrvRaw(context, request, cq));
    }
    ::grpc::Status receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> AsyncreceivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(AsyncreceivePlayAudioSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> PrepareAsyncreceivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(PrepareAsyncreceivePlayAudioSrvRaw(context, request, cq));
    }
    ::grpc::Status receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::service::AudioDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> AsyncreceiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(AsyncreceiveStopAudioSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>> PrepareAsyncreceiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>>(PrepareAsyncreceiveStopAudioSrvRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void registerAudioSrv(::grpc::ClientContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void receivePlayAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void receiveStopAudioSrv(::grpc::ClientContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>* AsyncregisterAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioServiceResponse>* PrepareAsyncregisterAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioServiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AsyncreceivePlayAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* PrepareAsyncreceivePlayAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* AsyncreceiveStopAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::AudioDataResponse>* PrepareAsyncreceiveStopAudioSrvRaw(::grpc::ClientContext* context, const ::service::AudioDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_registerAudioSrv_;
    const ::grpc::internal::RpcMethod rpcmethod_receivePlayAudioSrv_;
    const ::grpc::internal::RpcMethod rpcmethod_receiveStopAudioSrv_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status registerAudioSrv(::grpc::ServerContext* context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response);
    // receive data AudioAdapter
    virtual ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response);
    virtual ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_registerAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerAudioSrv() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_registerAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterAudioSrv(::grpc::ServerContext* context, ::service::AudioServiceRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::AudioServiceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_receivePlayAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_receivePlayAudioSrv() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_receivePlayAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreceivePlayAudioSrv(::grpc::ServerContext* context, ::service::AudioDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::AudioDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_receiveStopAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_receiveStopAudioSrv() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_receiveStopAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreceiveStopAudioSrv(::grpc::ServerContext* context, ::service::AudioDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::AudioDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_registerAudioSrv<WithAsyncMethod_receivePlayAudioSrv<WithAsyncMethod_receiveStopAudioSrv<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_registerAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_registerAudioSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::AudioServiceRequest, ::service::AudioServiceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::AudioServiceRequest* request, ::service::AudioServiceResponse* response) { return this->registerAudioSrv(context, request, response); }));}
    void SetMessageAllocatorFor_registerAudioSrv(
        ::grpc::experimental::MessageAllocator< ::service::AudioServiceRequest, ::service::AudioServiceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::AudioServiceRequest, ::service::AudioServiceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_registerAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerAudioSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerAudioSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_receivePlayAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_receivePlayAudioSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) { return this->receivePlayAudioSrv(context, request, response); }));}
    void SetMessageAllocatorFor_receivePlayAudioSrv(
        ::grpc::experimental::MessageAllocator< ::service::AudioDataRequest, ::service::AudioDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_receivePlayAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* receivePlayAudioSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* receivePlayAudioSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_receiveStopAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_receiveStopAudioSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::AudioDataRequest* request, ::service::AudioDataResponse* response) { return this->receiveStopAudioSrv(context, request, response); }));}
    void SetMessageAllocatorFor_receiveStopAudioSrv(
        ::grpc::experimental::MessageAllocator< ::service::AudioDataRequest, ::service::AudioDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::AudioDataRequest, ::service::AudioDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_receiveStopAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* receiveStopAudioSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* receiveStopAudioSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_registerAudioSrv<ExperimentalWithCallbackMethod_receivePlayAudioSrv<ExperimentalWithCallbackMethod_receiveStopAudioSrv<Service > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_registerAudioSrv<ExperimentalWithCallbackMethod_receivePlayAudioSrv<ExperimentalWithCallbackMethod_receiveStopAudioSrv<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_registerAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerAudioSrv() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_registerAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_receivePlayAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_receivePlayAudioSrv() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_receivePlayAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_receiveStopAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_receiveStopAudioSrv() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_receiveStopAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerAudioSrv() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_registerAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterAudioSrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_receivePlayAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_receivePlayAudioSrv() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_receivePlayAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreceivePlayAudioSrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_receiveStopAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_receiveStopAudioSrv() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_receiveStopAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreceiveStopAudioSrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_registerAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_registerAudioSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerAudioSrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_registerAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerAudioSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerAudioSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_receivePlayAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_receivePlayAudioSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->receivePlayAudioSrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_receivePlayAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* receivePlayAudioSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* receivePlayAudioSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_receiveStopAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_receiveStopAudioSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->receiveStopAudioSrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_receiveStopAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* receiveStopAudioSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* receiveStopAudioSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerAudioSrv() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::AudioServiceRequest, ::service::AudioServiceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::AudioServiceRequest, ::service::AudioServiceResponse>* streamer) {
                       return this->StreamedregisterAudioSrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioServiceRequest* /*request*/, ::service::AudioServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterAudioSrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::AudioServiceRequest,::service::AudioServiceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_receivePlayAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_receivePlayAudioSrv() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::AudioDataRequest, ::service::AudioDataResponse>* streamer) {
                       return this->StreamedreceivePlayAudioSrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_receivePlayAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status receivePlayAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedreceivePlayAudioSrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::AudioDataRequest,::service::AudioDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_receiveStopAudioSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_receiveStopAudioSrv() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::AudioDataRequest, ::service::AudioDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::AudioDataRequest, ::service::AudioDataResponse>* streamer) {
                       return this->StreamedreceiveStopAudioSrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_receiveStopAudioSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status receiveStopAudioSrv(::grpc::ServerContext* /*context*/, const ::service::AudioDataRequest* /*request*/, ::service::AudioDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedreceiveStopAudioSrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::AudioDataRequest,::service::AudioDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_registerAudioSrv<WithStreamedUnaryMethod_receivePlayAudioSrv<WithStreamedUnaryMethod_receiveStopAudioSrv<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_registerAudioSrv<WithStreamedUnaryMethod_receivePlayAudioSrv<WithStreamedUnaryMethod_receiveStopAudioSrv<Service > > > StreamedService;
};

// MQTT Service
class MQTTSrv final {
 public:
  static constexpr char const* service_full_name() {
    return "service.MQTTSrv";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::service::MQTTServiceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTServiceResponse>> AsyncregisterMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTServiceResponse>>(AsyncregisterMQTTSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTServiceResponse>> PrepareAsyncregisterMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTServiceResponse>>(PrepareAsyncregisterMQTTSrvRaw(context, request, cq));
    }
    // receive data MQTTAdapter
    virtual ::grpc::Status receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::service::MQTTDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>> AsyncreceiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>>(AsyncreceiveTriggerDataCANRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>> PrepareAsyncreceiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>>(PrepareAsyncreceiveTriggerDataCANRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // receive data MQTTAdapter
      virtual void receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTServiceResponse>* AsyncregisterMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTServiceResponse>* PrepareAsyncregisterMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>* AsyncreceiveTriggerDataCANRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service::MQTTDataResponse>* PrepareAsyncreceiveTriggerDataCANRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::service::MQTTServiceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>> AsyncregisterMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>>(AsyncregisterMQTTSrvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>> PrepareAsyncregisterMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>>(PrepareAsyncregisterMQTTSrvRaw(context, request, cq));
    }
    ::grpc::Status receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::service::MQTTDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>> AsyncreceiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>>(AsyncreceiveTriggerDataCANRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>> PrepareAsyncreceiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>>(PrepareAsyncreceiveTriggerDataCANRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void registerMQTTSrv(::grpc::ClientContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void receiveTriggerDataCAN(::grpc::ClientContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>* AsyncregisterMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::MQTTServiceResponse>* PrepareAsyncregisterMQTTSrvRaw(::grpc::ClientContext* context, const ::service::MQTTServiceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* AsyncreceiveTriggerDataCANRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service::MQTTDataResponse>* PrepareAsyncreceiveTriggerDataCANRaw(::grpc::ClientContext* context, const ::service::MQTTDataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_registerMQTTSrv_;
    const ::grpc::internal::RpcMethod rpcmethod_receiveTriggerDataCAN_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status registerMQTTSrv(::grpc::ServerContext* context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response);
    // receive data MQTTAdapter
    virtual ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_registerMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerMQTTSrv() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_registerMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterMQTTSrv(::grpc::ServerContext* context, ::service::MQTTServiceRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::MQTTServiceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_receiveTriggerDataCAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_receiveTriggerDataCAN() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_receiveTriggerDataCAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreceiveTriggerDataCAN(::grpc::ServerContext* context, ::service::MQTTDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::service::MQTTDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_registerMQTTSrv<WithAsyncMethod_receiveTriggerDataCAN<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_registerMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_registerMQTTSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service::MQTTServiceRequest, ::service::MQTTServiceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::MQTTServiceRequest* request, ::service::MQTTServiceResponse* response) { return this->registerMQTTSrv(context, request, response); }));}
    void SetMessageAllocatorFor_registerMQTTSrv(
        ::grpc::experimental::MessageAllocator< ::service::MQTTServiceRequest, ::service::MQTTServiceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::MQTTServiceRequest, ::service::MQTTServiceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_registerMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerMQTTSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerMQTTSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_receiveTriggerDataCAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_receiveTriggerDataCAN() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::service::MQTTDataRequest, ::service::MQTTDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::service::MQTTDataRequest* request, ::service::MQTTDataResponse* response) { return this->receiveTriggerDataCAN(context, request, response); }));}
    void SetMessageAllocatorFor_receiveTriggerDataCAN(
        ::grpc::experimental::MessageAllocator< ::service::MQTTDataRequest, ::service::MQTTDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service::MQTTDataRequest, ::service::MQTTDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_receiveTriggerDataCAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* receiveTriggerDataCAN(
      ::grpc::CallbackServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* receiveTriggerDataCAN(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_registerMQTTSrv<ExperimentalWithCallbackMethod_receiveTriggerDataCAN<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_registerMQTTSrv<ExperimentalWithCallbackMethod_receiveTriggerDataCAN<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_registerMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerMQTTSrv() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_registerMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_receiveTriggerDataCAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_receiveTriggerDataCAN() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_receiveTriggerDataCAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerMQTTSrv() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_registerMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterMQTTSrv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_receiveTriggerDataCAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_receiveTriggerDataCAN() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_receiveTriggerDataCAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreceiveTriggerDataCAN(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_registerMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_registerMQTTSrv() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerMQTTSrv(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_registerMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* registerMQTTSrv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* registerMQTTSrv(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_receiveTriggerDataCAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_receiveTriggerDataCAN() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->receiveTriggerDataCAN(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_receiveTriggerDataCAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* receiveTriggerDataCAN(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* receiveTriggerDataCAN(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerMQTTSrv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerMQTTSrv() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::MQTTServiceRequest, ::service::MQTTServiceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::MQTTServiceRequest, ::service::MQTTServiceResponse>* streamer) {
                       return this->StreamedregisterMQTTSrv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerMQTTSrv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerMQTTSrv(::grpc::ServerContext* /*context*/, const ::service::MQTTServiceRequest* /*request*/, ::service::MQTTServiceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterMQTTSrv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::MQTTServiceRequest,::service::MQTTServiceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_receiveTriggerDataCAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_receiveTriggerDataCAN() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service::MQTTDataRequest, ::service::MQTTDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service::MQTTDataRequest, ::service::MQTTDataResponse>* streamer) {
                       return this->StreamedreceiveTriggerDataCAN(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_receiveTriggerDataCAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status receiveTriggerDataCAN(::grpc::ServerContext* /*context*/, const ::service::MQTTDataRequest* /*request*/, ::service::MQTTDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedreceiveTriggerDataCAN(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service::MQTTDataRequest,::service::MQTTDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_registerMQTTSrv<WithStreamedUnaryMethod_receiveTriggerDataCAN<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_registerMQTTSrv<WithStreamedUnaryMethod_receiveTriggerDataCAN<Service > > StreamedService;
};

}  // namespace service


#endif  // GRPC_service_2eproto__INCLUDED
